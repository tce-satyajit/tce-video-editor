{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/satyajitpujari/projects/ce6/tce-video-editor/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst {\n  defaultArgs,\n  baseOptions\n} = require('./config');\n\nconst {\n  setLogging,\n  setCustomLogger,\n  log\n} = require('./utils/log');\n\nconst parseProgress = require('./utils/parseProgress');\n\nconst parseArgs = require('./utils/parseArgs');\n\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\n\nconst {\n  version\n} = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = { ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  const parseMessage = ({\n    type,\n    message\n  }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  const load = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* () {\n      log('info', 'load ffmpeg-core');\n\n      if (Core === null) {\n        log('info', 'loading ffmpeg-core');\n        /*\n         * In node environment, all paths are undefined as there\n         * is no need to set them.\n         */\n\n        const {\n          createFFmpegCore,\n          corePath,\n          workerPath,\n          wasmPath\n        } = yield getCreateFFmpegCore(options);\n        Core = yield createFFmpegCore({\n          /*\n           * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n           * as there is no document.currentScript in the context of content_scripts\n           */\n          mainScriptUrlOrBlob: corePath,\n          printErr: message => parseMessage({\n            type: 'fferr',\n            message\n          }),\n          print: message => parseMessage({\n            type: 'ffout',\n            message\n          }),\n\n          /*\n           * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n           * It is critical for browser environment and we override both wasm and worker paths\n           * as we are using blob URL instead of original URL to avoid cross origin issues.\n           */\n          locateFile: (path, prefix) => {\n            if (typeof window !== 'undefined') {\n              if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n                return wasmPath;\n              }\n\n              if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n                return workerPath;\n              }\n            }\n\n            return prefix + path;\n          }\n        });\n        ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n        log('info', 'ffmpeg-core loaded');\n      } else {\n        throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n      }\n    });\n\n    return function load() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  const isLoaded = () => Core !== null;\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(resolve => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n\n\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n\n  const setLogger = _logger => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', `use ffmpeg.wasm v${version}`);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS\n  };\n};","map":{"version":3,"sources":["/Users/satyajitpujari/projects/ce6/tce-video-editor/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"names":["defaultArgs","baseOptions","require","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","logging","logger","progress","optProgress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","type","load","createFFmpegCore","corePath","workerPath","wasmPath","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","isLoaded","run","_args","join","Promise","resolve","args","filter","s","length","FS","method","map","arg","ret","e","exit","setProgress","_progress","setLogger","_logger"],"mappings":"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","sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}